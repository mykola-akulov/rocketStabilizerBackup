#include <stdexcept>
#include <cstdlib>

double getDerivative(double* A, int frame_size, double time_s = 0.001){ //This function does not have optimization, so use this function, if your arrays (A) do not cover each other
    int i, sum = 0;
    for (i = 0; i < frame_size/2; ++i) sum -= A[i];
    for (i = frame_size/2; i < frame_size; ++i) sum += A[i];
    return 4 * sum / frame_size / frame_size / time_s;
}
double getDerivativeOpt(double * A, int frame_size, double time_s = 0.001, int step = 1) { //This function does not have optimization, so use this function, if your arrays (A) do not cover each other
    if(step >= frame_size){
        throw std::invalid_argument("Step is bigger or equal to the frame_size");
    }

    static double sum = 0;
    static double *elements = NULL;
    static int elements_size = 0;
    static int first_index = 0, last_index = 0;
    static int edge,num,beg,start,start2;
    double tmp1, tmp2;
    int i,j,k;

    if(!elements){ //sum has not been calculated. It's the first call of the function
        elements_size = frame_size / step + (frame_size % step != 0);
        elements = (double*)malloc(2*elements_size*sizeof(double));
        if(!elements) throw std::invalid_argument("Memory allocation error!");

        edge = (frame_size/2)%step;
        num = frame_size/2/step;
        first_index = 0;
        last_index = elements_size - 1;
        beg = frame_size - step;
        start = (frame_size/step)*step;
        start2 = (frame_size/step - 1)*step;

        for(k = 0; k < elements_size; ++k){
            elements[2*k] = 0.;
            elements[2*k + 1] = 0.;
            j = k * step;
            for(i = 0; i < step && j + i < frame_size; ++i) elements[2*k + (i >= edge)] += A[j + i];
        }
        sum = 0.;
        for (i = 0; i < num; ++i) sum -= (elements[2*i] + elements[2*i + 1]);

        sum += (-elements[2*num] + elements[2*num + 1]);

        for (i = num + 1; i < elements_size; ++i) sum += (elements[2*i] + elements[2*i + 1]);
    }
    else{
        sum += elements[2*first_index];
        sum += elements[2*first_index + 1];
        tmp1 = 0.;
        tmp2 = 0.;
        if(frame_size%step){
            for(i = beg; i < frame_size - frame_size % step; ++i){
                if(i - beg < edge) tmp1 += A[i];
                else tmp2 += A[i];
            }
        }
        elements[2*last_index] += tmp1;
        elements[2*last_index + 1] += tmp2;
        sum += tmp1 + tmp2; //update first and last indexes
        last_index = first_index;
        first_index = (first_index + 1) % elements_size;

        sum -= 2*elements[2*((first_index + num - 1)%elements_size) + 1];
        sum -= 2*elements[2*((first_index + num)%elements_size)];

        elements[2*last_index] = 0.;
        elements[2*last_index + 1] = 0.;
        if(frame_size%step){
            for (i = start; i < frame_size; ++i){
                if(i - start < edge)
                    elements[2*last_index] += A[i];
                else
                    elements[2*last_index + 1] += A[i];
            }
        }
        else{
            for(i = start2; i < frame_size; ++i){
                if(i - start2 < edge)
                    elements[2*last_index] += A[i];
                else
                    elements[2*last_index + 1] += A[i];
            }
        }
        sum += elements[2*last_index] + elements[2*last_index + 1];
    }
    return 4 * sum / frame_size / frame_size / time_s;
}
