#include <stdexcept>
#include <cstdlib>

double getDerivative(double* A, int frame_size, double time_s = 0.001){ //This function does not have optimization, so use this function, if your arrays (A) do not cover each other
    int i, sum = 0;
    for (i = 0; i < frame_size/2; ++i) sum -= A[i];
    for (i = frame_size/2; i < frame_size; ++i) sum += A[i];
    return sum / 2 / frame_size / time_s;
}
double getDerivativeOpt(double * A, int frame_size, double time_s = 0.001, int step = 1) { //This function does not have optimization, so use this function, if your arrays (A) do not cover each other
    if(step >= frame_size){
        throw std::invalid_argument("Step is bigger or equal to the frame_size");
    }

    static double sum = 0;
    static double *elements = NULL;
    static int elements_size = 0;
    static int first_index = 0, last_index = 0;
    double tmp = 0.;
    int i,j,k;

    if(!elements){ //sum has not been calculated. It's the first call of the function
        elements_size = frame_size / step + (frame_size % step != 0);
        elements = (double*)malloc(elements_size);
        if(!elements) throw std::invalid_argument("Memory allocation error!");

        first_index = 0;
        last_index = elements_size - 1;

        for(k = 0; k < elements_size; ++k){
            elements[k] = 0.;
            j = k * step;
            for(i = 0; i < step && j + i < frame_size; ++i) elements[k] += A[j + i];
        }

        sum = 0.;
        for (i = 0; i < elements_size; ++i) sum += elements[i];
    }
    else {
        sum -= elements[first_index];
        tmp = 0.;
        for (i = frame_size - step; i < frame_size - step + frame_size % step; ++i) tmp += A[i];
        elements[last_index] += tmp;
        sum += tmp; //update first and last indexes
        last_index = first_index;
        first_index = (first_index + 1) % elements_size;
        elements[last_index] = 0.;
        for (i = frame_size - step + frame_size % step; i < frame_size; ++i) elements[last_index] += A[i];
        sum += elements[last_index];
    }
    return sum / frame_size / time_s;
}
